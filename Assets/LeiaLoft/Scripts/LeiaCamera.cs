/****************************************************************
*
* Copyright 2019 Â© Leia Inc.  All rights reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Leia Inc. and its suppliers, if any.  The
* intellectual and technical concepts contained herein are
* proprietary to Leia Inc. and its suppliers and may be covered
* by U.S. and Foreign Patents, patents in process, and are
* protected by trade secret or copyright law.  Dissemination of
* this information or reproduction of this materials strictly
* forbidden unless prior written permission is obtained from
* Leia Inc.
*
****************************************************************
*/
using System;
using System.Collections;
using UnityEngine;
using System.Collections.Generic;

namespace LeiaLoft
{
    /// <summary>
    /// Contains some parameters of Unity camera that should be tracked and transferred to leia view cameras.
    /// </summary>
    public struct UnityCameraParams
    {
        public float FieldOfView { get; set; }
        public float Near { get; set; }
        public float Far { get; set; }
        public float Depth { get; set; }
        public int CullingMask { get; set; }
        public CameraClearFlags ClearFlags { get; set; }
        public Color BackgroundColor { get; set; }
        public bool AllowHDR { get; set; }
        public bool Orthographic { get; set; }
        public float OrthographicSize { get; set; }
        public Rect ViewportRect { get; set; }
        public RenderingPath RenderingPath { get; set; }
    }

    /// <summary>
    /// Script turns regular Unity camera into a Leia holographic camera.
    /// </summary>
    [RequireComponent(typeof(Camera))]
	[AddComponentMenu("LeiaLoft/Leia Camera")]
    public class LeiaCamera : MonoBehaviour, IEnumerable
    {
		private const string MissingLeiaView = "LeiaView gameobjects are autogenerated and required for rendering, removing or disabling is not recommended.";
        private const int LeiaCameraMask = 0;
        private const CameraClearFlags LeiaCameraClearFlags = CameraClearFlags.Depth;

        /// <summary>
        /// First created LeiaCamera
        /// </summary>
        public static LeiaCamera Instance { get; private set; }

        /// <summary>
        /// Caching Unity camera attached
        /// </summary>
        private Camera _camera;
        private UnityCameraParams _previousUnityCameraParams;

        /// <summary>
        /// Defines whether update is needed at next frame or not.
        /// </summary>
        private bool _isDirty = true;

        private LeiaView[] _leiaViews = null;
        [SerializeField]
        private float _disparityScaling = 1.0f;
        private float _previousDisparityScaling = 1.0f;
        [SerializeField]
        private float _convergenceDistance = 10f;
        private float _previousConvergenceDistance = 10f;
        [SerializeField]
        private bool _drawCameraBounds = true;
        [SerializeField]
        private Vector2 _cameraShift = Vector2.zero;
		[SerializeField]
		GameObject _renderObject;

        /// <summary>
        /// Returns Unity camera (not used for actual rendering, but parameters affect leia views)
        /// </summary>
        public Camera Camera
        {
            get
            {
                return _camera;
            }
        }

        /// <summary>
        /// Introduces perspective distortion in two possible directions which produces focal plane tilting
        /// </summary>
        public Vector2 CameraShift
        {
            get
            {
                return _cameraShift;
            }
            set
            {
                this.Trace(string.Format("Set CameraShift: {0}", value));
                _cameraShift = value;
                _isDirty = true;
            }
        }

        /// <summary>
        /// Determines if view frustum, leiaviews and focus plane should be highlighted in Editor (Scene tab)
        /// </summary>
        public bool DrawCameraBounds
        {
            get
            {
                return _drawCameraBounds;
            }
            set
            {
                _drawCameraBounds = value;
            }
        }

        /// <summary>
        /// Distance to a point where picture converges between all views (becomes focused)
        /// </summary>
        public float ConvergenceDistance
        {
            get
            {
                return _convergenceDistance;
            }
            set
            {
                value = Mathf.Max(1.0e-5f, value);

                if (Math.Abs(_convergenceDistance - value) < 1e-6)
                {
                    return;
                }
                this.Trace(string.Format("Set ConvergenceDistance: {0}", value));

                _convergenceDistance = value;
                _isDirty = true;
            }
        }

        /// <summary>
        /// Affects distance between LeiaViews
        /// </summary>
        public float BaselineScaling
        {
            get
            {
                return _disparityScaling;
            }
            set
            {
                value = Mathf.Max(1.0e-5f, value);

                if (Math.Abs(_disparityScaling - value) < 1e-6)
                {
                    return;
                }
                this.Trace(string.Format("Set BaselineScaling: {0}", value));

                _disparityScaling = value;
                _isDirty = true;
            }
        }

        /// <summary>
        /// Causes copying of all the post effects to the leiaviews with all parameters.
        /// Previous leiaview's effects and parameters will be discarded.
        /// </summary>
        public void UpdateEffects()
        {
            this.Debug("UpdateEffects");
            if (GetComponent<LeiaPostEffectsController>())
            {
                GetComponent<LeiaPostEffectsController>().ForceUpdate();
            }
        }

        /// <summary>
        /// Prepares array of empty LeiaViews, discarding previous if any
        /// Makes LeiaViews follow top-level Unity cameras "enabled" flag state
        /// </summary>
        public void SetViewCount(int count, bool forceUpdate = false)
        {
            this.Debug(string.Format("SetViewCount( {0}, {1})", count, forceUpdate));
            if (GetViewCount() == count && !forceUpdate)
            {
                return;
            }

            ClearViews();
            DisableUnnecessaryViews(count);

            _leiaViews = new LeiaView[count];

            for (var i = 0; i < count; i++)
            {
                var viewsParams = GetUnityCameraParams();

                _leiaViews[i] = new LeiaView(gameObject, viewsParams);
                // additional updates to LeiaViews occur in AbstractLeiaStateTemplate :: UpdateViews
            }

            ToggleLeiaViews(enabled);
        }

        /// <summary>
        /// Gets leiaview from array of LeiaViews by index
        /// </summary>
        public LeiaView GetView(int index)
        {
            return _leiaViews[index];
        }

        /// <summary>
        /// In Edit mode destroys all LeiaViews, in Play mode disables and puts into a pool for later reuse.
        /// </summary>
        public void ClearViews()
        {
            this.Debug("ClearViews");

            if (_leiaViews != null)
            {
                for (int i = 0; i < _leiaViews.Length; i++)
                {
                    var view = _leiaViews[i];

                    if (view != null)
                    {
                        _leiaViews[i].Release();
                        _leiaViews[i] = null;
                    }
                }
            }
        }

        /// <summary>
        /// In Edit mode destroys unnecessary LeiaViews, in Play mode disables and puts into a pool for later reuse.
        /// </summary>
        public void DisableUnnecessaryViews(int viewsCount)
        {
            this.Debug(string.Format("DisableUnnecessaryViews( {0})", viewsCount));

            var childrenCameras = GetComponentsInChildren<Camera>(true);
            int viewGameObjects = 0;

            for (int i = 0; i < childrenCameras.Length; i++)
            {
                var childCamera = childrenCameras[i];

                if (childCamera.transform.parent != transform || childCamera.GetComponent<LeiaCamera>() != null) { continue; }

                viewGameObjects++;

                if (!Application.isPlaying && viewGameObjects > viewsCount)
                {
                    DestroyImmediate(childCamera.gameObject);
                }
                else if (childCamera.gameObject.name == LeiaView.ENABLED_NAME)
                {
                    childCamera.gameObject.name = LeiaView.DISABLED_NAME;
                    // preserve the hide flag set in DisableUnnecessaryViews
                    // SetViewCount calls: Clear, Disable, Toggle.
                    // views will be toggled back on (potentially off) in Toggle.
                    childCamera.gameObject.hideFlags = HideFlags.HideInHierarchy;
                    childCamera.gameObject.SetActive(true);
                    childCamera.enabled = false;
                }
            }
        }

        /// <summary>
        /// Gets the count of leia views (0 if leiaView array is empty).
        /// </summary>
        public int GetViewCount()
        {
            return _leiaViews == null ? 0 : _leiaViews.Length;
        }

        /// <summary>
        /// Checks if some leiaView is missing or inactive (which can be caused by external manipulation)
        /// and in such case calls FixMissingOrInactiveLeiaviews()
        /// </summary>
        private void CheckMissingOrInactiveLeiaviews()
        {
            if (_leiaViews == null || Application.isPlaying)
            {
                return;
            }

            foreach (var view in _leiaViews)
            {
                if (view != null)
                {
                    if (!view.Object || !view.Object.activeInHierarchy ||
                        !view.Object.GetComponent<Camera>())
                    {
                        FixMissingOrInactiveLeiaviews();
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Recreates views and shows warning
        /// </summary>
        private void FixMissingOrInactiveLeiaviews()
        {
            SetViewCount(_leiaViews.Length, true);
            OnStateChanged();

            UpdateEffects();

            this.Warning(MissingLeiaView);
        }

        /// <summary>
        /// Enables or disables all LeiaViews
        /// </summary>
        private void ToggleLeiaViews(bool enable)
        {
            if (_leiaViews == null) { return; }

            foreach (var view in _leiaViews)
            {
                if (view != null)
                {
                    view.Enabled = enable;
                    if (enable)
                    {
                        // reveal this cam
                        view.Object.hideFlags = HideFlags.None;
                    }
                    else
                    {
                        // hide this cam
                        view.Object.hideFlags = HideFlags.HideInHierarchy;
                        view.Release();
                    }
                }
            }
        }

        /// <summary>
        /// A shortcut to Unity camera near clip plane setting
        /// </summary>
        public float NearClipPlane
        {
            get
            {
                return _camera.nearClipPlane;
            }
        }

        /// <summary>
        /// A shortcut to Unity camera far clip plane setting
        /// </summary>
        public float FarClipPlane
        {
            get
            {
                return _camera.farClipPlane;
            }
        }

        /// <summary>
        /// A shortcut to Unity camera field of view setting
        /// </summary>
        public float FieldOfView
        {
            get
            {
                return _camera.fieldOfView;
            }
        }

        /// <summary>
        /// Issues structure with a slice of current Unity camera params, useful for later comparison
        /// </summary>
        private UnityCameraParams GetUnityCameraParams()
        {
			bool hdr;
			#if UNITY_5_6_OR_NEWER
			hdr = _camera.allowHDR;
			#else
			hdr = _camera.hdr;
			#endif
            return new UnityCameraParams
            {
                FieldOfView = _camera.fieldOfView,
                Near = _camera.nearClipPlane,
                Far = _camera.farClipPlane,
                Depth = _camera.depth,
                CullingMask = _camera.cullingMask,
                ClearFlags = _camera.clearFlags,
                BackgroundColor = _camera.backgroundColor,
                Orthographic = _camera.orthographic,
                OrthographicSize = _camera.orthographicSize,
                ViewportRect = _camera.rect,
				AllowHDR = hdr,
                RenderingPath = _camera.renderingPath
            };
        }

        /// <summary>
        /// Memorize previous parameters, subscribe to LeiaDisplay's StateChanged event
        /// </summary>
        private void Awake()
        {
            _camera = GetComponent<Camera>();

            _previousUnityCameraParams = GetUnityCameraParams();

            if (Instance == null)
            {
                Instance = this;
            }

            LeiaDisplay.Instance.StateChanged -= OnStateChanged;
            LeiaDisplay.Instance.StateChanged += OnStateChanged;

			_camera.enabled = false;

			if(_renderObject == null)
			{
				CreateRenderObject();
				UpdateRenderCameraDepth();
			}
        }

        /// <summary>
        /// Invokes initial update to initialize views
        /// </summary>
        private void OnEnable()
        {
            this.Debug("OnEnable");
            this.Trace(gameObject.name);
            this.Trace("ConvergenceDistance: " + ConvergenceDistance);
            this.Trace("BaselineScaling: " + BaselineScaling);

            ToggleLeiaViews(true);
            _isDirty = true;
			Update();
        }

        /// <summary>
        /// Removes listener from StateChanged event, disables views
        /// </summary>
        private void OnDisable()
        {
            this.Debug("OnDisable");

            ToggleLeiaViews(false);
        }

        /// <summary>
        /// Removes listener (to avoid errors inside Unity Editor)
        /// </summary>
        private void OnDestroy()
        {
            this.Debug("OnDestroy");

            foreach (LeiaView lv in this)
            {
                lv.Release();
            }

            if (!LeiaDisplay.InstanceIsNull)
            {
                LeiaDisplay.Instance.StateChanged -= OnStateChanged;
            }
        }

        /// <summary>
        /// Method used to subscribe to LeiaDisplays StateChanged event
        /// </summary>
        private void OnStateChanged()
        {
            this.Debug("OnStateChanged");

            if (isActiveAndEnabled)
            {
                UpdatePostEffectsController();
                LeiaDisplay.Instance.UpdateViews(this);
            }
        }

        /// <summary>
        /// Asks LeiaDisplay to update all LeiaViews if required (if something changed in params)
        /// </summary>
        private void Update()
        {
            CheckMissingOrInactiveLeiaviews();

			UnityCameraParams currentUnityCameraParams = GetUnityCameraParams();

            bool camOrthoMatch = true;
            if (!currentUnityCameraParams.Equals(_previousUnityCameraParams))
            {
                camOrthoMatch = _previousUnityCameraParams.Orthographic == currentUnityCameraParams.Orthographic;
                _previousUnityCameraParams = currentUnityCameraParams;
                _isDirty = true;
				UpdateRenderCameraDepth();
            }

            if (Math.Abs(_convergenceDistance - _previousConvergenceDistance) > 1e-6)
            {
                _isDirty = true;
                _previousConvergenceDistance = _convergenceDistance;
            }

            if (Math.Abs(_disparityScaling - _previousDisparityScaling) > 1e-6)
            {
                _isDirty = true;
                _previousDisparityScaling = _disparityScaling;
            }

            if (_isDirty)
            {
                this.Debug("IsDirty detected");
                LeiaDisplay.Instance.UpdateViews(this);

                // while most LeiaCamera properties require just a view update when a camera param changes,
                // when Camera switches ortho <-> perspective, this requires a LeiaState / interlacing update
                if (!camOrthoMatch)
                {
                    LeiaDisplay.Instance.ForceLeiaStateUpdate();
                }
                
                RefreshViewsParams();
                _isDirty = false;
            }
        }

		private void UpdateRenderCameraDepth()
		{
			Camera renderCam = _renderObject.GetComponent<Camera>();
			renderCam.depth = _camera.depth + 0.1f;
		}

		/// <summary>
		/// Creates Object that signals rendering
		/// </summary>
		private void CreateRenderObject()
		{
			_renderObject = new GameObject("RenderCamera");
            _renderObject.transform.parent = this.transform;
            _renderObject.transform.localPosition = Vector3.zero;
            Camera _cam = _renderObject.AddComponent<Camera>();
            _cam.CopyFrom(transform.GetComponent<Camera>());

            // force culling mask always nothing
            _cam.cullingMask = 0x000000000;

            // render camera should automatically take same clear flags as root camera
            // this allows user to have a UI layer camera, plus a non-UI camera

            LeiaRenderCamera renderCam = _renderObject.AddComponent<LeiaRenderCamera>();
            _cam.tag = tag;
			renderCam.setLeiaCamera(this);
		}

        public void RefreshViewsParams()
        {
            var viewsParams = GetUnityCameraParams();

            foreach (LeiaView view in this)
            {
                if (view != null)
                {
                    view.RefreshParameters(viewsParams);
                }
            }
        }

        /// <summary>
        /// Updates post effects (copying them to leia views)
        /// </summary>
        private void UpdatePostEffectsController()
        {
            if (enabled && !LeiaDisplay.InstanceIsNull)
            {
                var controller = GetComponent<LeiaPostEffectsController>();

                if (controller == null)
                {
                    this.Debug("Adding LeiaPostEffectsController");
                    controller = gameObject.AddComponent<LeiaPostEffectsController>();
                    controller.Update();
                }
            }
            else
            {
                RemovePostEffectsController();
            }
        }

        /// <summary>
        /// Removes post effects controller from leiaCamera and post effects from views
        /// </summary>
        private void RemovePostEffectsController()
        {
            var controller = GetComponent<LeiaPostEffectsController>();

            if (controller != null)
            {
                controller.RestoreEffects();
                this.Debug("Destroying LeiaPostEffectsController");

                if (Application.isPlaying)
                {
                    Destroy(controller);
                }
                else
                {
                    DestroyImmediate(controller);
                }
            }
        }

        // This UpdatePrerenderedViews() function is called every frame just before interlacing.
        // Place code in this function to copy prerendered content into the views.
        // Previously called from AbstractLeiaStateTemplate, line 95
        // line 95 - //  camera.UpdatePrerenderedViews();
        [Obsolete]
        public void UpdatePrerenderedViews()
        {
            if (_leiaViews[0].TargetTexture == null)
            {
                return;
            }

            /*
            int viewWidth = GetView(0).TargetTexture.width;
            int viewHeight = GetView(0).TargetTexture.height;
            Texture2D grid = new Texture2D(viewWidth * 2, viewHeight * 3, TextureFormat.ARGB32, false, true);
            for (int y = viewHeight * 2; y < viewHeight * 3; y++)
            {
                for (int x = 0; x < viewWidth; x++)
                {
                    grid.SetPixel(x, y, Color.black);
                }
            }
            for (int y = viewHeight * 2; y < viewHeight * 3; y++)
            {
                for (int x = viewWidth; x < viewWidth * 2; x++)
                {
                    grid.SetPixel(x, y, Color.white);
                }
            }
            for (int y = viewHeight * 1; y < viewHeight * 2; y++)
            {
                for (int x = 0; x < viewWidth; x++)
                {
                    grid.SetPixel(x, y, Color.blue);
                }
            }
            for (int y = viewHeight * 1; y < viewHeight * 2; y++)
            {
                for (int x = viewWidth; x < viewWidth * 2; x++)
                {
                    grid.SetPixel(x, y, Color.yellow);
                }
            }
            for (int y = 0; y < viewHeight; y++)
            {
                for (int x = 0; x < viewWidth; x++)
                {
                    grid.SetPixel(x, y, Color.green);
                }
            }
            grid.Apply();

            UnpackUtil.Unpack(grid, viewWidth, viewHeight, 2, _leiaViews);

            */
        }

        /// <summary>
        /// Method for getting LeiaViews inside the LeiaCamera.
        /// </summary>
        /// <returns>
        /// Yields nothing if the LeiaCamera contains no LeiaViews (frame 0).
        /// Returns a single LeiaView in 2D mode.
        /// Yields LeiaViews in HPO mode.
        /// </returns>
        public IEnumerator GetEnumerator()
        {
            if (_leiaViews != null && GetViewCount() > 0)
            {
                for (int i = 0; i < GetViewCount(); i++)
                {
                    yield return _leiaViews[i];
                }
            }
        }
    }
}
